name: Develop Workflow

on:
  push:
    branches:
      - develop

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  ci:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Java 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Run tests
      run: ./gradlew test

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=sha,prefix=dev-

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

  cd:
    needs: ci
    runs-on: ubuntu-latest
    environment: dev

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup deployment environment
      run: |
        cat > .env << EOF
        APP_NAME=zappa-dev
        POSTGRES_DB=${{ vars.POSTGRES_DB }}
        POSTGRES_USER=${{ vars.POSTGRES_USER }}
        POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        DB_HOST=${{ vars.DB_HOST }}
        DB_PORT=${{ vars.DB_PORT }}
        SPRING_PROFILES_ACTIVE=dev
        SPRING_DATASOURCE_URL=jdbc:postgresql://${{ vars.DB_HOST }}:${{ vars.DB_PORT }}/${{ vars.POSTGRES_DB }}
        SPRING_DATASOURCE_USERNAME=${{ vars.POSTGRES_USER }}
        SPRING_DATASOURCE_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        SPRING_JPA_HIBERNATE_DDL_AUTO=validate
        SPRING_LIQUIBASE_ENABLED=true
        SERVER_PORT=6885
        APP_UPLOAD_DIR=/app/zappa/uploads

        # Docker image configuration
        REGISTRY=${{ env.REGISTRY }}
        IMAGE_NAME=${{ env.IMAGE_NAME }}
        IMAGE_TAG=dev-$(echo ${{ github.sha }} | cut -c1-7)
        EOF

    - name: Run smoke tests on runner
      run: |
        docker compose -f docker-compose.dev.yml down || true
        docker compose -f docker-compose.dev.yml pull
        docker compose -f docker-compose.dev.yml up -d

        echo "ðŸ” Waiting for application health check..."
        if timeout 120 bash -c 'until curl -sf http://localhost:6886/actuator/health; do sleep 5; done'; then
          echo "âœ… Health check passed"
          curl -f http://localhost:6886/actuator/health
        else
          echo "âŒ Health check failed after 120 seconds"
          echo "ðŸ“‹ Container logs:"
          docker compose -f docker-compose.dev.yml logs --tail=20
          exit 1
        fi

    - name: Decrypt SSH access key
      env:
        ACCESS_KEY_PASSPHRASE: ${{ secrets.ACCESS_KEY_PASSPHRASE }}
      run: |
        # Debug: Check if passphrase is available (don't print actual value)
        if [ -z "$ACCESS_KEY_PASSPHRASE" ]; then
          echo "âŒ ERROR: ACCESS_KEY_PASSPHRASE is empty"
          echo "Check that the secret is configured in the 'dev' environment"
          exit 1
        fi

        echo "ðŸ”“ Decrypting SSH key..."
        gpg --quiet --batch --yes --decrypt --passphrase="$ACCESS_KEY_PASSPHRASE" --output $HOME/access_key.pem access_key.pem.gpg
        chmod 600 $HOME/access_key.pem

    - name: Deploy to dev
      env:
        REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
        REMOTE_USER: ${{ secrets.REMOTE_USER }}
        REMOTE_PATH: ${{ vars.REMOTE_PATH }}
      run: |
        echo "ðŸš€ Deploying to dev..."

        # Ensure remote path exists and has proper permissions on remote server
        ssh -i $HOME/access_key.pem -o StrictHostKeyChecking=no $REMOTE_USER@$REMOTE_HOST << EOF
          if [ ! -d "$REMOTE_PATH" ]; then
            echo "ðŸ“ Creating deployment directory $REMOTE_PATH..."
            sudo mkdir -p $REMOTE_PATH
            sudo chown $REMOTE_USER:$REMOTE_USER $REMOTE_PATH
            sudo chmod 755 $REMOTE_PATH
            echo "âœ… Directory $REMOTE_PATH created"
          else
            echo "ðŸ“ Directory $REMOTE_PATH already exists"
          fi
        EOF

        # Upload deployment files to remote server
        echo "ðŸ“¤ Uploading deployment files..."
        scp -i $HOME/access_key.pem -o StrictHostKeyChecking=no \
          docker-compose.dev.yml .env $REMOTE_USER@$REMOTE_HOST:$REMOTE_PATH/

        # Deploy on remote server
        ssh -i $HOME/access_key.pem -o StrictHostKeyChecking=no $REMOTE_USER@$REMOTE_HOST "cd $REMOTE_PATH ; bash" << EOF
          set -e  # Exit on any error
        
          echo "ðŸ›‘ Stopping existing containers..."
          docker compose -f docker-compose.dev.yml down || true

          echo "ðŸ³ Pulling latest image..."
          docker compose -f docker-compose.dev.yml pull

          echo "â–¶ï¸ Starting services..."
          docker compose -f docker-compose.dev.yml up -d

          echo "ðŸ” Waiting for application health check..."
          if timeout 120 bash -c 'until curl -sf http://localhost:6886/actuator/health; do sleep 5; done'; then
            echo "ðŸ©º Health check passed"
          else
            echo "ðŸ©º Health check failed after 120 seconds"
            echo "ðŸ“‹ Container logs:"
            docker compose -f docker-compose.dev.yml logs --tail=20
            exit 1
          fi
        EOF

    - name: Cleanup SSH key
      if: always()
      run: |
        rm -f $HOME/access_key.pem
