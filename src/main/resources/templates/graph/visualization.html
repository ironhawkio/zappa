<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head th:replace="~{fragments/layout :: head}">
    <title>Knowledge Graph - Zappa</title>
</head>
<body>
    <nav th:replace="~{fragments/layout :: navbar}"></nav>

    <div th:replace="~{fragments/layout :: alerts}"></div>

    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h2>
                        <i class="fas fa-project-diagram me-2"></i>Knowledge Graph
                    </h2>
                    <div class="btn-group" role="group">
                        <button class="btn btn-outline-primary" onclick="resetGraph()">
                            <i class="fas fa-refresh me-1"></i>Reset View
                        </button>
                        <button class="btn btn-outline-success" onclick="highlightHubs()">
                            <i class="fas fa-star me-1"></i>Highlight Hubs
                        </button>
                        <button class="btn btn-outline-info" onclick="toggleLabels()">
                            <i class="fas fa-eye me-1"></i>Toggle Labels
                        </button>
                        <button id="savePositionsBtn" class="btn btn-outline-warning" onclick="savePositions()" disabled>
                            <i class="fas fa-save me-1"></i>Positions Saved
                        </button>
                        <button class="btn btn-outline-danger" onclick="resetPositions()">
                            <i class="fas fa-undo me-1"></i>Reset Layout
                        </button>
                    </div>
                </div>

                <!-- Group Selection -->
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-body py-2">
                                <div class="row align-items-center">
                                    <div class="col-md-8">
                                        <div class="d-flex align-items-center">
                                            <label class="form-label me-3 mb-0">
                                                <i class="fas fa-filter me-1"></i>Graph Scope:
                                            </label>
                                            <select class="form-select form-select-sm me-3" id="groupSelector" onchange="changeGraphGroup()">
                                                <option value="">All Notes (Global Graph)</option>
                                                <option th:each="group : ${allGroups}"
                                                        th:value="${group.id}"
                                                        th:text="${group.name}"
                                                        th:style="'color: ' + ${group.displayColor}"
                                                        th:selected="${selectedGroup != null and selectedGroup.id == group.id}">Group</option>
                                            </select>
                                            <div class="form-check" th:if="${selectedGroup != null}">
                                                <input class="form-check-input" type="checkbox" id="includeSubGroups"
                                                       th:checked="${includeSubGroups}" onchange="changeGraphGroup()">
                                                <label class="form-check-label" for="includeSubGroups">
                                                    Include subgroups
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div th:if="${selectedGroup != null}" class="alert alert-info py-1 mb-0">
                                            <small>
                                                <i th:class="${selectedGroup.displayIcon} + ' me-1'"></i>
                                                <strong th:text="${selectedGroup.name}">Group</strong>
                                                <span th:text="'Graph (' + ${totalNodes} + ' nodes, ' + ${totalLinks} + ' links)'">Graph</span>
                                            </small>
                                        </div>
                                        <div th:if="${selectedGroup == null}" class="alert alert-secondary py-1 mb-0">
                                            <small>
                                                <i class="fas fa-globe me-1"></i>
                                                <strong>Global Graph</strong>
                                                <span th:text="'(' + ${totalNodes} + ' nodes, ' + ${totalLinks} + ' links)'">Graph</span>
                                            </small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tag Filtering -->
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="card">
                            <div class="card-body py-2">
                                <div class="row align-items-center">
                                    <div class="col-md-6">
                                        <div class="d-flex align-items-center">
                                            <label class="form-label me-3 mb-0">
                                                <i class="fas fa-tags me-1"></i>Filter by Tags:
                                            </label>
                                            <div class="tag-selector-wrapper me-3" style="min-width: 300px;">
                                                <div class="tag-input-container">
                                                    <div class="selected-tags" id="selectedTagsContainer"></div>
                                                    <div class="search-input-wrapper">
                                                        <input type="text"
                                                               id="tagSearchInput"
                                                               class="tag-search-input"
                                                               placeholder="Search and select tags..."
                                                               autocomplete="off"
                                                               spellcheck="false">
                                                        <div class="search-suggestion" id="searchSuggestion"></div>
                                                    </div>
                                                    <input type="hidden" id="tagInput" th:value="${selectedTags}">
                                                </div>
                                                <div class="tag-dropdown" id="tagDropdown" style="display: none;">
                                                    <div class="tag-dropdown-content">
                                                        <div th:each="tag : ${allTags}"
                                                             class="tag-option"
                                                             th:data-tag-name="${tag.name}"
                                                             th:data-tag-color="${tag.color}">
                                                            <span class="tag-color-indicator" th:style="'background-color: ' + ${tag.color}"></span>
                                                            <span th:text="${tag.name}">Tag Name</span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            <select class="form-select form-select-sm me-3" id="tagFilterType" style="max-width: 120px;">
                                                <option value="any" th:selected="${tagFilter == 'any'}">Any Tags</option>
                                                <option value="all" th:selected="${tagFilter == 'all'}">All Tags</option>
                                            </select>
                                            <button class="btn btn-sm btn-outline-primary" onclick="applyTagFilter()">
                                                <i class="fas fa-filter me-1"></i>Apply
                                            </button>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="d-flex flex-wrap gap-1">
                                            <small class="text-muted me-2">Quick tags:</small>
                                            <span th:each="tag : ${allTags}"
                                                  th:if="${tagStat.count <= 8}"
                                                  class="badge bg-secondary quick-tag"
                                                  style="cursor: pointer;"
                                                  th:data-tag-name="${tag.name}">
                                                <span th:text="${tag.name}">Tag</span>
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <div class="row">
            <!-- Graph visualization -->
            <div class="col-md-9">
                <div class="card">
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-network-wired me-2"></i>Interactive Graph
                        </h6>
                    </div>
                    <div class="card-body p-0">
                        <div id="graph-container" style="height: 600px; background: #f8f9fa;">
                            <!-- Cytoscape.js will create its canvas here -->
                        </div>
                    </div>
                </div>

                <!-- Graph controls -->
                <div class="card mt-3">
                    <div class="card-body py-2">
                        <div class="row align-items-center">
                            <div class="col-md-3">
                                <label class="form-label small">Link Type:</label>
                                <select id="linkTypeFilter" class="form-select form-select-sm" onchange="filterByLinkType()">
                                    <option value="">All Types</option>
                                    <option value="REFERENCES">References</option>
                                    <option value="EXTENDS">Extends</option>
                                    <option value="IMPLEMENTS">Implements</option>
                                    <option value="RELATES_TO">Related To</option>
                                    <option value="CONTRADICTS">Contradicts</option>
                                </select>
                            </div>
                            <div class="col-md-3">
                                <label class="form-label small">Min Weight:</label>
                                <input type="range" id="weightFilter" class="form-range" min="1" max="10" value="1"
                                       oninput="filterByWeight(this.value)">
                                <small class="text-muted">Weight: <span id="weightValue">1</span></small>
                            </div>
                            <div class="col-md-3">
                                <button class="btn btn-sm btn-outline-secondary w-100" onclick="exportGraph()">
                                    <i class="fas fa-download me-1"></i>Export SVG
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Node details sidebar -->
            <div class="col-md-3">
                <div class="card">
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-info-circle me-2"></i>Node Details
                        </h6>
                    </div>
                    <div class="card-body" id="nodeDetails">
                        <div class="text-center text-muted py-4">
                            <i class="fas fa-mouse-pointer fa-2x mb-2"></i>
                            <p>Click on a node to see details</p>
                        </div>
                    </div>
                </div>

                <!-- Legend -->
                <div class="card mt-3">
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-palette me-2"></i>Legend
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="small">
                            <div class="mb-2">
                                <strong>Graph Legend:</strong>
                            </div>

                            <div class="mb-2">
                                <strong>Link Colors (Weight):</strong>
                            </div>
                            <div class="mb-1">
                                <span style="display: inline-block; width: 20px; height: 3px; background-color: #dc3545; margin-right: 5px;"></span>
                                <small>Critical (8-10)</small>
                            </div>
                            <div class="mb-1">
                                <span style="display: inline-block; width: 20px; height: 3px; background-color: #fd7e14; margin-right: 5px;"></span>
                                <small>Important (6-7)</small>
                            </div>
                            <div class="mb-1">
                                <span style="display: inline-block; width: 20px; height: 3px; background-color: #ffc107; margin-right: 5px;"></span>
                                <small>Moderate (4-5)</small>
                            </div>
                            <div class="mb-3">
                                <span style="display: inline-block; width: 20px; height: 3px; background-color: #28a745; margin-right: 5px;"></span>
                                <small>Light (1-3)</small>
                            </div>

                            <div class="mb-2">
                                <strong>Node Size:</strong> Connection count
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quick actions -->
                <div class="card mt-3">
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-bolt me-2"></i>Quick Actions
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="d-grid gap-2">
                            <button class="btn btn-sm btn-outline-primary" onclick="findShortestPath()">
                                <i class="fas fa-route me-1"></i>Find Path
                            </button>
                            <button class="btn btn-sm btn-outline-success" onclick="centerGraph()">
                                <i class="fas fa-crosshairs me-1"></i>Center Graph
                            </button>
                            <a href="/notes/new" class="btn btn-sm btn-outline-secondary">
                                <i class="fas fa-plus me-1"></i>Add Note
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer th:replace="~{fragments/layout :: footer}"></footer>

    <!-- Path finding modal -->
    <div class="modal fade" id="pathModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Find Shortest Path</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p>Select two nodes on the graph, then click this button to find the shortest path between them.</p>
                    <div id="pathResult"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div th:replace="~{fragments/layout :: scripts}"></div>

    <!-- D3.js -->
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>

    <style>
        /* Tag Selector Styles */
        .tag-selector-wrapper {
            position: relative;
        }

        .tag-input-container {
            border: 1px solid #ced4da;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: white;
            min-height: 38px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            align-items: center;
            cursor: text;
        }

        .tag-input-container:focus-within {
            border-color: #86b7fe;
            outline: 0;
            box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .selected-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.125rem 0.5rem;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #495057;
        }

        .selected-tag .tag-remove {
            margin-left: 0.375rem;
            cursor: pointer;
            color: #6c757d;
        }

        .selected-tag .tag-remove:hover {
            color: #dc3545;
        }

        .search-input-wrapper {
            position: relative;
            flex: 1;
            min-width: 120px;
        }

        .tag-search-input {
            border: none;
            outline: none;
            width: 100%;
            padding: 0.25rem 0;
            font-size: 0.875rem;
            background: transparent;
            position: relative;
            z-index: 2;
        }

        .search-suggestion {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 0.25rem 0;
            font-size: 0.875rem;
            color: #6c757d;
            pointer-events: none;
            z-index: 1;
            white-space: nowrap;
            overflow: hidden;
        }

        .suggestion-match {
            color: transparent;
        }

        .suggestion-completion {
            color: #6c757d;
            font-style: italic;
        }

        .tag-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
            z-index: 10000;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .tag-dropdown.show {
            display: block !important;
        }

        .tag-dropdown-content {
            padding: 0.5rem 0;
        }

        .tag-option {
            padding: 0.375rem 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            /* Prevent flicker on hover */
            transition: none;
            user-select: none;
            pointer-events: auto;
        }

        .tag-option:hover {
            background: #f8f9fa;
            /* Stable hover state */
            transition: background-color 0.1s ease;
        }

        .tag-option.selected {
            background: #e7f1ff;
            color: #0f5132;
        }

        .tag-option.highlighted {
            background: #007bff;
            color: white;
        }

        /* Highlight matching text in dropdown options */
        .tag-option .match-highlight {
            background-color: #fff3cd;
            font-weight: bold;
            padding: 0 2px;
            border-radius: 2px;
        }

        .tag-option.highlighted .match-highlight {
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
        }

        .tag-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .no-tags-found {
            padding: 0.75rem;
            text-align: center;
            color: #6c757d;
            font-style: italic;
            font-size: 0.875rem;
        }
    </style>

    <script>
        // Graph visualization with Cytoscape.js
        let cy = null;
        let graphData = null;
        let selectedNodes = [];
        let showLabels = true;
        let positionsModified = false;

        // Weight-based color function
        function getLinkColor(weight) {
            if (weight >= 8) return '#dc3545';      // Red - Critical
            if (weight >= 6) return '#fd7e14';      // Orange - Important
            if (weight >= 4) return '#ffc107';      // Yellow - Moderate
            return '#28a745';                       // Green - Light
        }

        document.addEventListener('DOMContentLoaded', function() {
            initializeGraph();
            loadGraphData();
            initializeTagSelector();

            // Add event listeners for quick tag buttons
            document.addEventListener('click', function(e) {
                if (e.target.closest('.quick-tag')) {
                    const tagName = e.target.closest('.quick-tag').getAttribute('data-tag-name');
                    if (tagName) {
                        addQuickTag(tagName);
                    }
                }
            });
        });

        function initializeTagSelector() {
            const tagSearchInput = document.getElementById('tagSearchInput');
            const tagDropdown = document.getElementById('tagDropdown');
            const tagInput = document.getElementById('tagInput');
            const selectedTagsContainer = document.getElementById('selectedTagsContainer');
            const searchSuggestion = document.getElementById('searchSuggestion');
            let selectedTags = [];
            let availableTags = [];
            let currentSuggestion = '';
            let highlightedIndex = -1;

            // Build available tags list from DOM
            const tagOptions = tagDropdown.querySelectorAll('.tag-option');
            tagOptions.forEach(option => {
                availableTags.push({
                    name: option.getAttribute('data-tag-name'),
                    color: option.getAttribute('data-tag-color'),
                    element: option
                });
            });

            // Parse initially selected tags
            if (tagInput.value) {
                selectedTags = tagInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                renderSelectedTags();
            }

            // Show dropdown when input is focused
            tagSearchInput.addEventListener('focus', function() {
                const searchTerm = tagSearchInput.value.trim();
                if (searchTerm) {
                    // If there's already text, filter and show matches
                    const matchCount = filterTagOptions(searchTerm.toLowerCase());
                    if (matchCount > 0) {
                        showDropdown();
                    }
                } else {
                    // If empty, show all available tags
                    filterTagOptions('');
                    showDropdown();
                }
            });

            // Hide dropdown when clicking outside - simplified
            document.addEventListener('click', function(e) {
                const isInsideSelector = e.target.closest('.tag-selector-wrapper');
                const isInsideDropdown = e.target.closest('.tag-dropdown');

                if (!isInsideSelector && !isInsideDropdown && isDropdownVisible) {
                    hideDropdown();
                }
            });

            // Hide dropdown on scroll and resize - but debounced
            let hideTimeout;
            function scheduleHide() {
                clearTimeout(hideTimeout);
                hideTimeout = setTimeout(() => {
                    if (isDropdownVisible) {
                        hideDropdown();
                    }
                }, 100);
            }

            window.addEventListener('scroll', scheduleHide, { passive: true });
            window.addEventListener('resize', scheduleHide, { passive: true });

            // Prevent any event bubbling from dropdown
            tagDropdown.addEventListener('mouseenter', function(e) {
                e.stopPropagation();
            });

            tagDropdown.addEventListener('mouseleave', function(e) {
                e.stopPropagation();
            });

            tagDropdown.addEventListener('click', function(e) {
                e.stopPropagation();
                e.preventDefault();
            });

            // Search functionality with suggestions and debouncing
            let searchTimeout;
            tagSearchInput.addEventListener('input', function() {
                const searchTerm = this.value;
                const searchTermLower = searchTerm.toLowerCase();

                // Update search suggestion immediately
                updateSuggestion(searchTerm);

                // Debounce the dropdown filtering
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const matchCount = filterTagOptions(searchTermLower);
                    // Always show dropdown if there's a search term and matches
                    if (searchTerm.trim() && matchCount > 0) {
                        showDropdown();
                    } else if (!searchTerm.trim()) {
                        hideDropdown();
                    }
                }, 50); // Very fast response for immediate feedback
            });

            // Handle tag option clicks with isolated event delegation
            tagDropdown.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopImmediatePropagation();

                const tagOption = e.target.closest('.tag-option');
                if (tagOption) {
                    const tagName = tagOption.getAttribute('data-tag-name');
                    if (tagName) {
                        selectTag(tagName);
                    }
                }
            }, { capture: true });

            // Handle keyboard navigation for suggestions
            tagSearchInput.addEventListener('keydown', function(e) {
                const visibleOptions = Array.from(tagDropdown.querySelectorAll('.tag-option:not([style*="display: none"])'));

                switch (e.key) {
                    case 'Enter':
                        e.preventDefault();
                        if (highlightedIndex >= 0 && visibleOptions[highlightedIndex]) {
                            // Priority 1: Select highlighted option from dropdown
                            const tagName = visibleOptions[highlightedIndex].getAttribute('data-tag-name');
                            selectTag(tagName);
                        } else if (currentSuggestion && tagSearchInput.value.trim()) {
                            // Priority 2: Accept current suggestion
                            selectTag(currentSuggestion);
                        } else if (visibleOptions.length === 1) {
                            // Priority 3: If only one option visible, select it
                            const tagName = visibleOptions[0].getAttribute('data-tag-name');
                            selectTag(tagName);
                        } else if (visibleOptions.length > 1) {
                            // Priority 4: Multiple options available, highlight first one
                            highlightedIndex = 0;
                            updateHighlight(visibleOptions);
                        }
                        break;

                    case 'Tab':
                        if (currentSuggestion && tagSearchInput.value.trim() !== currentSuggestion) {
                            e.preventDefault();
                            // Accept current suggestion
                            tagSearchInput.value = currentSuggestion;
                            updateSuggestion(currentSuggestion);
                        } else if (visibleOptions.length > 0 && highlightedIndex < 0) {
                            e.preventDefault();
                            // Highlight first option if no suggestion available
                            highlightedIndex = 0;
                            updateHighlight(visibleOptions);
                            showDropdown();
                        }
                        break;

                    case 'ArrowDown':
                        e.preventDefault();
                        if (visibleOptions.length > 0) {
                            highlightedIndex = Math.min(highlightedIndex + 1, visibleOptions.length - 1);
                            updateHighlight(visibleOptions);
                            showDropdown();
                        }
                        break;

                    case 'ArrowUp':
                        e.preventDefault();
                        if (visibleOptions.length > 0) {
                            highlightedIndex = Math.max(highlightedIndex - 1, -1);
                            updateHighlight(visibleOptions);
                            showDropdown();
                        }
                        break;

                    case 'Escape':
                        hideDropdown();
                        highlightedIndex = -1;
                        break;
                }
            });

            let isDropdownVisible = false;
            let dropdownPending = false;

            function updateSuggestion(searchTerm) {
                if (!searchTerm) {
                    searchSuggestion.innerHTML = '';
                    currentSuggestion = '';
                    return;
                }

                // Find the best matching tag that starts with the search term
                const unselectedTags = availableTags.filter(tag =>
                    !selectedTags.includes(tag.name)
                );

                // Get all matching tags
                const matchingTags = unselectedTags.filter(tag =>
                    tag.name.toLowerCase().includes(searchTerm.toLowerCase())
                );

                if (matchingTags.length === 0) {
                    searchSuggestion.innerHTML = '';
                    currentSuggestion = '';
                    return;
                }

                // Sort by relevance: exact match > starts with > contains
                matchingTags.sort((a, b) => {
                    const aLower = a.name.toLowerCase();
                    const bLower = b.name.toLowerCase();
                    const searchLower = searchTerm.toLowerCase();

                    // Exact match first
                    if (aLower === searchLower && bLower !== searchLower) return -1;
                    if (aLower !== searchLower && bLower === searchLower) return 1;

                    // Then starts with
                    if (aLower.startsWith(searchLower) && !bLower.startsWith(searchLower)) return -1;
                    if (!aLower.startsWith(searchLower) && bLower.startsWith(searchLower)) return 1;

                    // Then shorter names (more likely to be what user wants)
                    if (aLower.startsWith(searchLower) && bLower.startsWith(searchLower)) {
                        return a.name.length - b.name.length;
                    }

                    // Finally alphabetical
                    return a.name.localeCompare(b.name);
                });

                const bestMatch = matchingTags[0];
                const exactMatch = bestMatch.name.toLowerCase() === searchTerm.toLowerCase();

                if (exactMatch) {
                    // Exact match - no suggestion needed, but show count of other matches
                    if (matchingTags.length > 1) {
                        searchSuggestion.innerHTML = `<span class="suggestion-completion">(+${matchingTags.length - 1} more)</span>`;
                    } else {
                        searchSuggestion.innerHTML = '';
                    }
                    currentSuggestion = '';
                } else if (bestMatch.name.toLowerCase().startsWith(searchTerm.toLowerCase())) {
                    // Show suggestion for completion
                    const matchPart = bestMatch.name.substring(0, searchTerm.length);
                    const completionPart = bestMatch.name.substring(searchTerm.length);

                    let suggestionHTML = `<span class="suggestion-match">${matchPart}</span><span class="suggestion-completion">${completionPart}</span>`;

                    // Add count of other matches if more than one
                    if (matchingTags.length > 1) {
                        suggestionHTML += `<span class="suggestion-completion"> (+${matchingTags.length - 1} more)</span>`;
                    }

                    searchSuggestion.innerHTML = suggestionHTML;
                    currentSuggestion = bestMatch.name;
                } else {
                    // No starts-with match, just show count
                    searchSuggestion.innerHTML = `<span class="suggestion-completion">${matchingTags.length} match${matchingTags.length > 1 ? 'es' : ''}</span>`;
                    currentSuggestion = '';
                }
            }

            function updateHighlight(visibleOptions) {
                // Remove existing highlights
                visibleOptions.forEach(option => option.classList.remove('highlighted'));

                // Add highlight to current index
                if (highlightedIndex >= 0 && visibleOptions[highlightedIndex]) {
                    visibleOptions[highlightedIndex].classList.add('highlighted');
                }
            }

            function highlightMatchingText(option, tagName, searchTerm) {
                if (!searchTerm) {
                    resetHighlighting(option);
                    return;
                }

                const tagTextSpan = option.querySelector('span:last-child');
                if (!tagTextSpan) return;

                const searchLower = searchTerm.toLowerCase();
                const tagNameLower = tagName.toLowerCase();
                const matchIndex = tagNameLower.indexOf(searchLower);

                if (matchIndex >= 0) {
                    const beforeMatch = tagName.substring(0, matchIndex);
                    const matchText = tagName.substring(matchIndex, matchIndex + searchTerm.length);
                    const afterMatch = tagName.substring(matchIndex + searchTerm.length);

                    tagTextSpan.innerHTML = beforeMatch +
                        '<span class="match-highlight">' + matchText + '</span>' +
                        afterMatch;
                } else {
                    tagTextSpan.textContent = tagName;
                }
            }

            function resetHighlighting(option) {
                const tagTextSpan = option.querySelector('span:last-child');
                if (tagTextSpan) {
                    const tagName = option.getAttribute('data-tag-name');
                    if (tagName) {
                        tagTextSpan.textContent = tagName;
                    }
                }
            }

            function showDropdown() {
                if (isDropdownVisible) return;

                isDropdownVisible = true;
                tagDropdown.classList.add('show');
            }

            function hideDropdown() {
                if (!isDropdownVisible) return;

                isDropdownVisible = false;
                tagDropdown.classList.remove('show');

                // Clear highlights and reset text highlighting
                tagDropdown.querySelectorAll('.tag-option.highlighted').forEach(option => {
                    option.classList.remove('highlighted');
                });
                tagDropdown.querySelectorAll('.tag-option').forEach(option => {
                    resetHighlighting(option);
                });
                highlightedIndex = -1;

                tagSearchInput.value = '';
                searchSuggestion.innerHTML = '';
                currentSuggestion = '';
            }

            function filterTagOptions(searchTerm) {
                const options = tagDropdown.querySelectorAll('.tag-option');
                let hasVisibleOptions = false;
                let matchingTags = [];

                // Reset highlight when filtering
                highlightedIndex = -1;
                options.forEach(option => option.classList.remove('highlighted'));

                options.forEach(option => {
                    const tagName = option.getAttribute('data-tag-name');
                    if (!tagName) return;

                    const tagNameLower = tagName.toLowerCase();
                    const isSelected = selectedTags.includes(tagName);

                    let matches = false;
                    let exactMatch = false;

                    if (!searchTerm) {
                        // Show all unselected tags if no search term
                        matches = !isSelected;
                    } else {
                        // Check if tag matches the search term
                        matches = tagNameLower.includes(searchTerm.toLowerCase()) && !isSelected;
                        exactMatch = tagNameLower === searchTerm.toLowerCase();
                    }

                    if (matches) {
                        option.style.display = 'flex';
                        hasVisibleOptions = true;

                        // Highlight matching text in the tag name
                        highlightMatchingText(option, tagName, searchTerm);

                        // Collect matching tags for sorting
                        matchingTags.push({
                            element: option,
                            name: tagName,
                            nameLower: tagNameLower,
                            startsWithSearch: searchTerm ? tagNameLower.startsWith(searchTerm.toLowerCase()) : false,
                            exactMatch: exactMatch
                        });
                    } else {
                        option.style.display = 'none';
                        // Reset highlighting when hidden
                        resetHighlighting(option);
                    }
                });

                // Sort matching tags: exact matches first, then starts-with matches, then contains matches
                if (searchTerm && matchingTags.length > 0) {
                    matchingTags.sort((a, b) => {
                        // Exact matches first
                        if (a.exactMatch && !b.exactMatch) return -1;
                        if (!a.exactMatch && b.exactMatch) return 1;

                        // Then starts-with matches
                        if (a.startsWithSearch && !b.startsWithSearch) return -1;
                        if (!a.startsWithSearch && b.startsWithSearch) return 1;

                        // Then alphabetical
                        return a.name.localeCompare(b.name);
                    });

                    // Reorder DOM elements to match sorted order
                    const dropdownContent = tagDropdown.querySelector('.tag-dropdown-content');
                    matchingTags.forEach(tag => {
                        dropdownContent.appendChild(tag.element);
                    });
                }

                // Show/hide no results message
                let noResultsMsg = tagDropdown.querySelector('.no-tags-found');
                if (!hasVisibleOptions && searchTerm) {
                    if (!noResultsMsg) {
                        noResultsMsg = document.createElement('div');
                        noResultsMsg.className = 'no-tags-found';
                        noResultsMsg.textContent = 'No tags found';
                        tagDropdown.querySelector('.tag-dropdown-content').appendChild(noResultsMsg);
                    }
                    noResultsMsg.style.display = 'block';
                } else if (noResultsMsg) {
                    noResultsMsg.style.display = 'none';
                }

                return matchingTags.length;
            }

            function selectTag(tagName) {
                if (!selectedTags.includes(tagName)) {
                    selectedTags.push(tagName);
                    renderSelectedTags();
                    updateTagInput();
                    hideDropdown();

                    // Clear search input and suggestions
                    tagSearchInput.value = '';
                    searchSuggestion.innerHTML = '';
                    currentSuggestion = '';
                    highlightedIndex = -1;
                }
            }

            function removeTag(tagName) {
                selectedTags = selectedTags.filter(tag => tag !== tagName);
                renderSelectedTags();
                updateTagInput();
            }

            function renderSelectedTags() {
                selectedTagsContainer.innerHTML = '';
                selectedTags.forEach(tagName => {
                    const tagElement = document.createElement('span');
                    tagElement.className = 'selected-tag';
                    tagElement.innerHTML = `
                        <span>${tagName}</span>
                        <span class="tag-remove" onclick="removeSelectedTag('${tagName}')">&times;</span>
                    `;
                    selectedTagsContainer.appendChild(tagElement);
                });
            }

            function updateTagInput() {
                tagInput.value = selectedTags.join(', ');
            }

            // Global function for removing tags
            window.removeSelectedTag = function(tagName) {
                removeTag(tagName);
            };

            // Global function for adding tags (used by quick tags)
            window.addTagToSelector = function(tagName) {
                selectTag(tagName);
            };
        }

        function initializeGraph() {
            const container = document.getElementById('graph-container');

            cy = cytoscape({
                container: container,
                style: [
                    // Node styles
                    {
                        selector: 'node',
                        style: {
                            'background-color': 'data(color)',
                            'width': 'data(size)',
                            'height': 'data(size)',
                            'label': 'data(title)',
                            'text-valign': 'bottom',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'color': '#333',
                            'text-background-color': 'white',
                            'text-background-opacity': 0.8,
                            'text-background-padding': '2px',
                            'border-width': 2,
                            'border-color': '#fff'
                        }
                    },
                    // Edge styles
                    {
                        selector: 'edge',
                        style: {
                            'line-color': 'data(color)',
                            'width': 'data(width)',
                            'opacity': 0.8,
                            'curve-style': 'bezier',
                            'target-arrow-shape': 'triangle',
                            'target-arrow-color': 'data(color)'
                        }
                    },
                    // Selected node styles
                    {
                        selector: 'node:selected',
                        style: {
                            'border-color': '#dc3545',
                            'border-width': 4
                        }
                    },
                    // Highlighted styles
                    {
                        selector: '.highlighted',
                        style: {
                            'opacity': 1
                        }
                    },
                    {
                        selector: '.dimmed',
                        style: {
                            'opacity': 0.3
                        }
                    },
                    // Path highlight styles
                    {
                        selector: '.path-highlight',
                        style: {
                            'line-color': '#ff6b6b',
                            'target-arrow-color': '#ff6b6b',
                            'width': 6,
                            'opacity': 1
                        }
                    }
                ],
                layout: {
                    name: 'cose',
                    animate: true,
                    animationDuration: 1000,
                    fit: true,
                    padding: 50,
                    nodeOverlap: 20,
                    idealEdgeLength: 100,
                    edgeElasticity: 100,
                    nestingFactor: 5,
                    gravity: 80,
                    numIter: 1000,
                    initialTemp: 200,
                    coolingFactor: 0.95,
                    minTemp: 1.0
                }
            });

            // Add event listeners
            setupCytoscapeEvents();
        }

        function setupCytoscapeEvents() {
            // Node click event
            cy.on('tap', 'node', function(evt) {
                const node = evt.target;
                const nodeId = node.id();

                // Toggle selection
                if (selectedNodes.includes(nodeId)) {
                    selectedNodes = selectedNodes.filter(id => id !== nodeId);
                    node.unselect();
                } else {
                    selectedNodes.push(nodeId);
                    if (selectedNodes.length > 2) {
                        const oldNode = cy.getElementById(selectedNodes.shift());
                        oldNode.unselect();
                    }
                    node.select();
                }

                loadNodeDetails(nodeId);
            });

            // Node hover effects
            cy.on('mouseover', 'node', function(evt) {
                const node = evt.target;
                const connectedEdges = node.connectedEdges();
                const connectedNodes = connectedEdges.connectedNodes();

                // Dim all elements
                cy.elements().addClass('dimmed');

                // Highlight connected elements
                node.removeClass('dimmed').addClass('highlighted');
                connectedNodes.removeClass('dimmed').addClass('highlighted');
                connectedEdges.removeClass('dimmed').addClass('highlighted');
            });

            cy.on('mouseout', 'node', function(evt) {
                cy.elements().removeClass('dimmed highlighted');
            });

            // Edge hover effects
            cy.on('mouseover', 'edge', function(evt) {
                const edge = evt.target;
                edge.style('width', Math.max(6, edge.data('width') * 1.5));
            });

            cy.on('mouseout', 'edge', function(evt) {
                const edge = evt.target;
                edge.style('width', edge.data('width'));
            });

            // Track position changes
            cy.on('position', 'node', function(evt) {
                positionsModified = true;
                updateSaveButtonState();
            });

            cy.on('free', 'node', function(evt) {
                // Auto-save positions after drag ends
                if (positionsModified) {
                    savePositions();
                }
            });
        }

        function loadGraphData() {
            const groupId = getSelectedGroupId();
            const includeSubGroups = getIncludeSubGroups();
            const tags = getSelectedTags();
            const tagFilter = getTagFilterType();

            let url = '/graph/data';
            const params = new URLSearchParams();

            if (groupId) {
                params.append('group', groupId);
                params.append('includeSubGroups', includeSubGroups);
            }

            if (tags) {
                params.append('tags', tags);
                params.append('tagFilter', tagFilter);
            }

            if (params.toString()) {
                url += '?' + params.toString();
            }

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    graphData = data;
                    renderGraph();
                })
                .catch(error => {
                    console.error('Error loading graph data:', error);
                    showError('Failed to load graph data');
                });
        }

        function getSelectedGroupId() {
            const selector = document.getElementById('groupSelector');
            return selector ? selector.value : '';
        }

        function getIncludeSubGroups() {
            const checkbox = document.getElementById('includeSubGroups');
            return checkbox ? checkbox.checked : false;
        }

        function getSelectedTags() {
            const input = document.getElementById('tagInput');
            return input ? input.value.trim() : '';
        }

        function getTagFilterType() {
            const select = document.getElementById('tagFilterType');
            return select ? select.value : 'any';
        }

        function applyTagFilter() {
            const groupId = getSelectedGroupId();
            const includeSubGroups = getIncludeSubGroups();
            const tags = getSelectedTags();
            const tagFilter = getTagFilterType();

            // Update URL to reflect current selection
            const url = new URL(window.location);

            if (groupId) {
                url.searchParams.set('group', groupId);
                url.searchParams.set('includeSubGroups', includeSubGroups);
            } else {
                url.searchParams.delete('group');
                url.searchParams.delete('includeSubGroups');
            }

            if (tags) {
                url.searchParams.set('tags', tags);
                url.searchParams.set('tagFilter', tagFilter);
            } else {
                url.searchParams.delete('tags');
                url.searchParams.delete('tagFilter');
            }

            // Update URL without page reload
            window.history.pushState({}, '', url);

            // Reload graph data
            loadGraphData();
        }

        function addQuickTag(tagName) {
            if (window.addTagToSelector) {
                window.addTagToSelector(tagName);
                applyTagFilter();
            }
        }

        function changeGraphGroup() {
            const groupId = getSelectedGroupId();
            const includeSubGroups = getIncludeSubGroups();

            // Update URL to reflect current selection
            const url = new URL(window.location);
            if (groupId) {
                url.searchParams.set('group', groupId);
                url.searchParams.set('includeSubGroups', includeSubGroups);
            } else {
                url.searchParams.delete('group');
                url.searchParams.delete('includeSubGroups');
            }

            // Update URL without page reload
            window.history.pushState({}, '', url);

            // Reload graph data
            loadGraphData();
        }

        function renderGraph() {
            if (!graphData || !cy) return;

            // Convert D3 format to Cytoscape format
            const elements = [];

            // Add nodes
            graphData.nodes.forEach(node => {
                elements.push({
                    data: {
                        id: node.id,
                        title: node.title,
                        color: node.color,
                        size: node.size * 2, // Cytoscape sizes work differently
                        linkCount: node.linkCount
                    }
                });
            });

            // Add edges
            graphData.links.forEach(link => {
                elements.push({
                    data: {
                        id: `${link.source.id || link.source}-${link.target.id || link.target}`,
                        source: link.source.id || link.source,
                        target: link.target.id || link.target,
                        color: getLinkColor(link.weight),
                        width: Math.max(2, link.weight / 2),
                        weight: link.weight,
                        type: link.type
                    }
                });
            });

            // Update graph with new data
            cy.elements().remove();
            cy.add(elements);

            // Run layout
            const layout = cy.layout({
                name: 'cose',
                animate: true,
                animationDuration: 1000,
                fit: true,
                padding: 50,
                idealEdgeLength: 100,
                nodeOverlap: 20
            });

            layout.run();

            // Reset selections
            selectedNodes = [];

            // Load saved positions after layout
            layout.on('layoutstop', function() {
                loadSavedPositions();
            });
        }

        // Hybrid storage: localStorage + server API
        let serverSaveTimeout = null;

        function savePositions() {
            if (!cy) return;

            const positions = {};
            cy.nodes().forEach(node => {
                const pos = node.position();
                positions[node.id()] = { x: pos.x, y: pos.y };
            });

            const groupKey = getSelectedGroupId() || 'global';

            // 1. Immediate save to localStorage (fast)
            const storageKey = `graph-positions-${groupKey}`;
            const positionData = {
                positions: positions,
                timestamp: Date.now(),
                groupKey: groupKey
            };
            localStorage.setItem(storageKey, JSON.stringify(positionData));

            // 2. Debounced save to server (background)
            clearTimeout(serverSaveTimeout);
            serverSaveTimeout = setTimeout(() => {
                saveToServer(groupKey, positions);
            }, 2000); // Wait 2 seconds before saving to server

            positionsModified = false;
            updateSaveButtonState();

            // Show temporary success message
            showToast('Positions saved locally!', 'success');
        }

        async function saveToServer(groupKey, positions) {
            try {
                const response = await fetch(`/api/graph/positions/${groupKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(positions)
                });

                if (response.ok) {
                    showToast('Positions synced to server!', 'info');
                } else {
                    console.warn('Failed to save positions to server:', response.status);
                }
            } catch (error) {
                console.warn('Server save failed (offline?):', error);
            }
        }

        async function loadSavedPositions() {
            if (!cy) return;

            const groupKey = getSelectedGroupId() || 'global';
            const storageKey = `graph-positions-${groupKey}`;

            // 1. Try localStorage first (instant)
            const localData = localStorage.getItem(storageKey);
            let localPositions = null;
            let localTimestamp = 0;

            if (localData) {
                try {
                    const parsed = JSON.parse(localData);
                    localPositions = parsed.positions || parsed; // Support old format
                    localTimestamp = parsed.timestamp || 0;

                    // Apply local positions immediately
                    applyPositions(localPositions);
                    console.log('Applied local positions');
                } catch (e) {
                    console.warn('Failed to load local positions:', e);
                }
            }

            // 2. Load from server and merge (background)
            try {
                const response = await fetch(`/api/graph/positions/${groupKey}`);
                if (response.ok) {
                    const serverPositions = await response.json();

                    // Use server positions if local is missing or server is newer
                    if (!localPositions || Object.keys(serverPositions).length > 0) {
                        applyPositions(serverPositions);

                        // Update localStorage with server data
                        const positionData = {
                            positions: serverPositions,
                            timestamp: Date.now(),
                            groupKey: groupKey
                        };
                        localStorage.setItem(storageKey, JSON.stringify(positionData));

                        console.log('Applied server positions and synced to localStorage');
                    }
                }
            } catch (error) {
                console.log('Server load failed (using local positions):', error);
            }
        }

        function applyPositions(positions) {
            if (!positions || !cy) return;

            cy.nodes().forEach(node => {
                const nodeId = node.id();
                if (positions[nodeId]) {
                    node.position(positions[nodeId]);
                }
            });
        }

        async function resetPositions() {
            const groupKey = getSelectedGroupId() || 'global';
            const storageKey = `graph-positions-${groupKey}`;

            // Clear localStorage
            localStorage.removeItem(storageKey);

            // Clear server storage
            try {
                await fetch(`/api/graph/positions/${groupKey}`, {
                    method: 'DELETE'
                });
                console.log('Cleared server positions');
            } catch (error) {
                console.warn('Failed to clear server positions:', error);
            }

            positionsModified = false;
            updateSaveButtonState();

            // Re-run layout
            const layout = cy.layout({
                name: 'cose',
                animate: true,
                animationDuration: 1000,
                fit: true,
                padding: 50
            });
            layout.run();

            showToast('Positions reset to automatic layout', 'info');
        }

        function updateSaveButtonState() {
            const saveBtn = document.getElementById('savePositionsBtn');
            if (saveBtn) {
                saveBtn.disabled = !positionsModified;
                saveBtn.textContent = positionsModified ? 'Save Positions' : 'Positions Saved';
            }
        }

        function showToast(message, type = 'info') {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.className = `alert alert-${type} position-fixed`;
            toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 250px;';
            toast.innerHTML = `
                <i class="fas fa-info-circle me-2"></i>${message}
                <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
            `;
            document.body.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.remove();
                }
            }, 3000);
        }


        function loadNodeDetails(nodeId) {
            fetch(`/graph/node/${nodeId}`)
                .then(response => response.json())
                .then(data => {
                    const detailsContainer = document.getElementById('nodeDetails');
                    detailsContainer.innerHTML = `
                        <h6>${data.title}</h6>
                        <p class="small text-muted">${data.content || 'No content'}</p>
                        <div class="mb-2">
                        </div>
                        <div class="mb-2">
                            ${data.tags.map(tag => `<span class="badge bg-primary">${tag}</span>`).join(' ')}
                        </div>
                        <hr>
                        <div class="small">
                            <div><strong>Total Links:</strong> ${data.totalLinks}</div>
                            <div><strong>Avg Weight:</strong> ${data.averageWeight?.toFixed(1) || 'N/A'}</div>
                        </div>
                        <hr>
                        <div class="small">
                            <div><strong>Outgoing (${data.outgoingLinks.length}):</strong></div>
                            ${data.outgoingLinks.map(link =>
                                `<div class="ms-2">→ ${link.target} (${link.type})</div>`
                            ).join('')}
                            <div class="mt-2"><strong>Incoming (${data.incomingLinks.length}):</strong></div>
                            ${data.incomingLinks.map(link =>
                                `<div class="ms-2">← ${link.source} (${link.type})</div>`
                            ).join('')}
                        </div>
                        <hr>
                        <div class="d-grid gap-1">
                            <a href="/notes/${data.id}" class="btn btn-sm btn-primary">View Note</a>
                            <a href="/notes/${data.id}/edit" class="btn btn-sm btn-outline-secondary">Edit Note</a>
                        </div>
                    `;
                })
                .catch(error => console.error('Error loading node details:', error));
        }


        function resetGraph() {
            if (!cy) return;
            selectedNodes = [];
            cy.elements().unselect();
            cy.elements().removeClass('dimmed highlighted');
            cy.fit();
        }

        function highlightHubs() {
            if (!cy || !graphData) return;
            const maxConnections = Math.max(...graphData.nodes.map(n => n.linkCount));
            const threshold = maxConnections * 0.7;

            cy.nodes().forEach(node => {
                const linkCount = node.data('linkCount');
                if (linkCount >= threshold) {
                    node.style({
                        'border-color': '#ffc107',
                        'border-width': 6
                    });
                } else {
                    node.style({
                        'border-color': '#fff',
                        'border-width': 2
                    });
                }
            });
        }

        function toggleLabels() {
            if (!cy) return;
            showLabels = !showLabels;
            if (showLabels) {
                cy.style().selector('node').style('label', 'data(title)').update();
            } else {
                cy.style().selector('node').style('label', '').update();
            }
        }


        function filterByLinkType() {
            if (!cy) return;
            const linkType = document.getElementById('linkTypeFilter').value;

            cy.edges().forEach(edge => {
                if (!linkType || edge.data('type') === linkType) {
                    edge.style('opacity', 0.8);
                } else {
                    edge.style('opacity', 0.1);
                }
            });
        }

        function filterByWeight(value) {
            if (!cy) return;
            document.getElementById('weightValue').textContent = value;

            cy.edges().forEach(edge => {
                if (edge.data('weight') >= value) {
                    edge.style('opacity', 0.8);
                } else {
                    edge.style('opacity', 0.1);
                }
            });
        }

        function findShortestPath() {
            if (selectedNodes.length !== 2) {
                alert('Please select exactly 2 nodes to find the shortest path');
                return;
            }

            const modal = new bootstrap.Modal(document.getElementById('pathModal'));
            modal.show();

            // Find shortest path using Cytoscape's built-in algorithm
            const node1 = cy.getElementById(selectedNodes[0]);
            const node2 = cy.getElementById(selectedNodes[1]);
            const path = cy.elements().dijkstra(node1, function(edge) {
                return edge.data('weight');
            }).pathTo(node2);

            // Highlight the path
            cy.elements().removeClass('path-highlight');
            path.addClass('path-highlight');
        }

        function centerGraph() {
            if (!cy) return;
            cy.fit(null, 50);
        }


        function exportGraph() {
            if (!cy) return;

            // Export as PNG using Cytoscape's built-in export
            const png64 = cy.png({
                output: 'blob',
                bg: 'white',
                full: true,
                scale: 2
            });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(png64);
            a.download = 'knowledge-graph.png';
            a.click();
        }

        function showError(message) {
            const container = document.getElementById('graph-container');
            container.innerHTML = `
                <div class="d-flex align-items-center justify-content-center h-100">
                    <div class="text-center text-muted">
                        <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                        <h5>Error Loading Graph</h5>
                        <p>${message}</p>
                        <button class="btn btn-primary" onclick="loadGraphData()">
                            <i class="fas fa-refresh me-1"></i>Retry
                        </button>
                    </div>
                </div>
            `;
        }

        // Handle window resize
        window.addEventListener('resize', function() {
            if (cy) {
                cy.resize();
                cy.fit();
            }
        });

        // Sync to server on page unload
        window.addEventListener('beforeunload', function() {
            if (positionsModified && cy) {
                const positions = {};
                cy.nodes().forEach(node => {
                    const pos = node.position();
                    positions[node.id()] = { x: pos.x, y: pos.y };
                });

                const groupKey = getSelectedGroupId() || 'global';

                // Synchronous save for page unload
                navigator.sendBeacon(`/api/graph/positions/${groupKey}`,
                    JSON.stringify(positions));
            }
        });
    </script>
</body>
</html>